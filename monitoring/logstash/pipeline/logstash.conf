input {
  # Receive logs from Filebeat
  beats {
    port => 5000
  }
  
  # Direct TCP input for application logs (JSON format)
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # UDP input for high-throughput logging
  udp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Parse Pino JSON logs (from feedback-pipeline)
  if [service] == "feedback-pipeline" or [service] == "worker" or [service] == "api-server" {
    json {
      source => "message"
      target => "parsed"
    }
    
    # Extract fields from Pino format
    if [parsed][level] {
      mutate {
        add_field => { "log_level" => "%{[parsed][level]}" }
      }
    }
    
    if [parsed][msg] {
      mutate {
        add_field => { "log_message" => "%{[parsed][msg]}" }
      }
    }
    
    # Convert Pino numeric levels to text
    if [log_level] == "30" {
      mutate { replace => { "log_level" => "info" } }
    } else if [log_level] == "40" {
      mutate { replace => { "log_level" => "warn" } }
    } else if [log_level] == "50" {
      mutate { replace => { "log_level" => "error" } }
    } else if [log_level] == "60" {
      mutate { replace => { "log_level" => "fatal" } }
    }
  }
  
  # Parse Express server logs
  if [service] == "server" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}" }
    }
  }
  
  # Add timestamp
  date {
    match => [ "timestamp", "ISO8601" ]
    target => "@timestamp"
  }
  
  # Extract HTTP status codes for monitoring
  if [log_message] =~ /status.*(\d{3})/ {
    grok {
      match => { "log_message" => "status.*(?<http_status>\d{3})" }
    }
    
    mutate {
      convert => { "http_status" => "integer" }
    }
  }
  
  # Tag errors for alerting
  if [log_level] in ["error", "fatal"] {
    mutate {
      add_tag => ["error_alert"]
    }
  }
  
  # Extract sentiment analysis results
  if [service] == "worker" and [log_message] =~ /sentiment/ {
    grok {
      match => { "log_message" => "sentiment.*(?<sentiment_label>POSITIVE|NEGATIVE|NEUTRAL)" }
    }
  }
  
  # Parse authentication events
  if [log_message] =~ /(login|register|logout|verification)/ {
    mutate {
      add_tag => ["auth_event"]
    }
  }
  
  # Parse feedback submission events
  if [log_message] =~ /feedback.*submitted/ {
    mutate {
      add_tag => ["feedback_event"]
    }
  }
}

output {
  # Send all logs to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "crm-logs-%{+YYYY.MM.dd}"
    
    # Create separate indices for different log types
    if "error_alert" in [tags] {
      index => "crm-errors-%{+YYYY.MM.dd}"
    }
    
    if "auth_event" in [tags] {
      index => "crm-auth-%{+YYYY.MM.dd}"
    }
    
    if "feedback_event" in [tags] {
      index => "crm-feedback-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (optional - comment out in production)
  stdout {
    codec => rubydebug
  }
}
